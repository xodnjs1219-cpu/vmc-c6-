## 💳 1. 신규 사용자 가입 (Clerk / 구글 로그인 연동)

**1. 입력 (Input)**
* 사용자가 `/sign-up` 또는 `/sign-in` 페이지에 접근합니다.
* Clerk UI에 표시된 'Google로 계속하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  Clerk이 Google OAuth 인증 팝업/리디렉션을 처리합니다.
2.  사용자가 Google 계정을 선택하고 인증을 완료합니다.
3.  Clerk이 Google로부터 인증 응답을 받아, Clerk 시스템 내에 신규 사용자를 생성합니다. (신규 가입의 경우)
4.  Clerk이 Webhook 엔드포인트(`api/webhooks/clerk`)로 `user.created` 이벤트를 전송합니다.
5.  백엔드 API가 Webhook 시그니처를 검증하여 유효한 요청인지 확인합니다.
6.  **(엣지케이스)** Webhook 검증 실패 시: 401 Unauthorized 응답을 반환하고 처리를 중단합니다.
7.  (검증 성공) Webhook 페이로드에서 `user_id`와 `email` 등 필요 정보를 추출합니다.
8.  Supabase `users` 테이블에 해당 `user_id`를 PK로 하는 신규 유저 레코드를 생성합니다.
9.  Supabase `subscriptions` 테이블에 해당 `user_id`와 연결된 레코드를 생성합니다.
    * `plan_type`: 'Free'
    * `remaining_tries`: 3
    * `next_payment_date`: null
    * `billing_key`: null
10. **(엣지케이스)** DB 트랜잭션(8, 9) 실패 시: 500 Server Error 응답을 반환합니다. (Clerk는 Webhook 재시도를 시도합니다.)
11. (처리 성공) Clerk 시스템에 200 OK 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) Clerk의 플로우에 따라 Google 인증이 완료되고, 설정된 리디렉션 페이지(예: `/dashboard`)로 이동되며 로그인 상태가 됩니다.
* (시스템 측) Supabase DB에 신규 사용자와 'Free' 상태의 구독 정보가 저장됩니다.

---

## 🆓 2. Free 사용자의 사주 분석 (성공)

**1. 입력 (Input)**
* (인증 상태) 사용자가 `/new-analysis` 페이지에 접근합니다.
* 폼에 필수 사주 정보(이름, 생년월일, 양/음력)를 입력합니다. (시는 '모름' 체크 가능)
* '분석하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 입력값의 유효성(필수 항목 누락 등)을 검증합니다.
2.  (검증 통과) 백엔드 API로 '분석 요청'을 전송합니다. (Clerk `userId` 포함)
3.  백엔드 API가 `userId`를 기준으로 Supabase `subscriptions` 테이블을 조회합니다.
4.  (조건 검증) `plan_type` = 'Free' 이고 `remaining_tries` >= 1 인지 확인합니다.
5.  **(엣지케이스)** 횟수가 0인 경우: 403 Forbidden 응답을 반환합니다. (유저플로우 3 참조)
6.  Gemini 2.5 Flash 모델 API에 입력된 사주 정보로 분석을 요청합니다.
7.  **(엣지케이스)** Gemini API 호출 실패 시: 503 Service Unavailable 응답을 반환합니다. (횟수 차감 없음)
8.  (Gemini 응답 성공) API로부터 사주 풀이 결과(요약, 상세)를 수신합니다.
9.  Supabase `analyses` 테이블에 새로운 레코드를 생성하여 분석 결과를 저장합니다.
10. Supabase `subscriptions` 테이블에서 해당 유저의 `remaining_tries`를 1 차감합니다. (예: 3 -> 2)
11. **(엣지케이스)** DB 저장/업데이트(9, 10) 실패 시: 500 Server Error 응답을 반환합니다. (횟수 차감 없음)
12. (모든 처리 성공) 프론트엔드로 AI 분석 결과(요약, 상세) 및 새로 생성된 `analysisId`를 포함하여 200 OK 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) 현재 페이지(`/new-analysis`)에 **요약 내용이 포함된 모달(Modal)**이 표시됩니다. 모달에는 '상세보기' 버튼이 포함됩니다.
* (시스템 측) `analyses` 테이블에 분석 내역 1건이 추가되고, `subscriptions` 테이블의 `remaining_tries`가 1 감소합니다.

---

## 🚫 3. Free 사용자의 사주 분석 (횟수 소진)

**1. 입력 (Input)**
* (인증 상태, Free 플랜) 사용자가 `/new-analysis` 페이지에 접근합니다.
* 폼에 필수 사주 정보를 입력합니다.
* '분석하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 입력값의 유효성을 검증합니다.
2.  (검증 통과) 백엔드 API로 '분석 요청'을 전송합니다. (Clerk `userId` 포함)
3.  백엔드 API가 `userId`를 기준으로 Supabase `subscriptions` 테이블을 조회합니다.
4.  (조건 검증) `plan_type` = 'Free' 이고 `remaining_tries` = 0 인지 확인합니다.
5.  (조건 충족) Gemini API 호출 등 후속 처리를 중단합니다.
6.  프론트엔드로 '횟수 소진'을 의미하는 특정 에러 코드(예: 403 Forbidden / `QUOTA_EXCEEDED`)를 반환합니다.

**3. 출력 (Output)**
* (사용자 측) 프론트엔드가 '횟수 소진' 에러 응답을 수신합니다.
* 간단한 알림(토스트 등)을 표시한 후, 즉시 `/subscription` (구독 관리) 페이지로 자동 리디렉션합니다.
* (시스템 측) 데이터 변경이 없습니다.

---

## 🚀 4. 신규 Pro 플랜 구독 신청 (빌링키 발급 및 첫 결제)

**1. 입력 (Input)**
* (인증 상태, Free 플랜) 사용자가 `/subscription` 페이지에 접근합니다.
* 'Pro 구독하기' (월 3,900원) 버튼을 클릭합니다.
* (토스페이먼츠 UI) 사용자가 결제수단(카드 등) 정보 입력 및 인증을 완료합니다.

**2. 처리 (Processing)**
1.  (프론트엔드) 'Pro 구독하기' 버튼 클릭 시, 백엔드 API (`/api/payments/subscribe`)에 구독 요청을 보냅니다.
2.  (백엔드) `userId`를 `customerKey`로 사용하여 토스페이먼츠 API를 호출, 결제창 생성 정보를 요청합니다.
3.  **(엣지케이스)** 토스 API 호출 실패 시: 백엔드가 503 Service Unavailable 응답을 반환합니다.
4.  (백엔드) 결제창 정보를 프론트엔드로 전달합니다.
5.  (프론트엔드) 전달받은 정보로 토스페이먼츠 결제 SDK를 띄웁니다.
6.  (사용자) 토스 UI 내에서 결제수단 인증을 완료합니다.
7.  **(엣지케이스)** 사용자가 토스 UI에서 중도 취소한 경우: 프론트엔드는 사용자를 `/subscription` 페이지로 돌려보냅니다. (시스템 변경 없음)
8.  **(엣지케이스)** 카드 인증 실패 시: 토스 UI가 사용자에게 실패 사유를 알립니다. (시스템 변경 없음)
9.  (인증 성공) 토스 SDK가 프론트엔드로 임시 `authKey`를 반환합니다.
10. (프론트엔드) `authKey`를 백엔드 API (`/api/payments/confirm`)로 전송하여 결제 승인 및 빌링키 저장을 요청합니다.
11. (백엔드) `authKey`와 `customerKey`(`userId`)를 사용하여 토스 API에 **빌링키(영구)** 를 요청하고, **즉시 해당 빌링키로 첫 결제(3,900원)** 를 시도합니다.
12. **(엣지케이스)** 첫 결제 실패 시: 백엔드는 빌링키를 DB에 저장하지 않고, 프론트엔드에 402 Payment Required (결제 실패) 응답을 반환합니다.
13. (첫 결제 성공) 토스로부터 성공적인 결제 응답을 수신합니다.
14. (백엔드) Supabase `subscriptions` 테이블에서 해당 유저의 레코드를 업데이트합니다.
    * `plan_type`: 'Pro'
    * `remaining_tries`: 10 (즉시 부여)
    * `billing_key`: (암호화된) 토스 빌링키
    * `next_payment_date`: (현재 날짜 + 1개월)
    * `subscribed_at`: (현재 타임스탬프)
15. **(크리티컬 엣지케이스)** 결제는 성공했으나 DB 업데이트(14) 실패 시: 시스템은 해당 오류를 로깅하고, 사용자에게 500 Server Error를 반환합니다. (고객 문의 예상)
16. (DB 업데이트 성공) 프론트엔드에 200 OK (구독 성공) 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) 토스 결제창이 닫히고, `/subscription` 페이지 UI가 갱신됩니다. (Pro 상태, 횟수 10회, 다음 결제일 표시, '해지하기' 버튼으로 변경)
* (시스템 측) Supabase DB에 유저의 Pro 상태와 암호화된 빌링키가 저장됩니다.

---

## ✨ 5. Pro 사용자의 사주 분석 (성공)

**1. 입력 (Input)**
* (인증 상태, Pro 플랜) 사용자가 `/new-analysis` 페이지에 접근합니다.
* (UI) Gemini 2.5 Flash / 2.5 Pro 모델 선택 UI가 노출됩니다.
* 사용자가 원하는 모델(예: '2.5 Pro')을 선택합니다.
* 폼에 필수 사주 정보를 입력합니다.
* '분석하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 입력값의 유효성을 검증합니다.
2.  (검증 통과) 백엔드 API로 '분석 요청'을 전송합니다. (`userId`와 **선택한 모델 타입** 포함)
3.  백엔드 API가 `userId`를 기준으로 Supabase `subscriptions` 테이블을 조회합니다.
4.  (조건 검증) `plan_type` = 'Pro' 이고 `remaining_tries` >= 1 인지 확인합니다.
5.  **(엣지케이스)** 횟수가 0인 경우: 403 Forbidden 응답을 반환합니다. (유저플로우 6 참조)
6.  사용자가 선택한 Gemini 모델(Flash 또는 Pro)의 API에 사주 정보로 분석을 요청합니다.
7.  **(엣지케이스)** Gemini API 호출 실패 시: 503 Service Unavailable 응답을 반환합니다. (횟수 차감 없음)
8.  (Gemini 응답 성공) API로부터 사주 풀이 결과(요약, 상세)를 수신합니다.
9.  Supabase `analyses` 테이블에 새로운 레코드를 생성하여 분석 결과를 저장합니다. (**사용된 모델 타입** 포함)
10. Supabase `subscriptions` 테이블에서 해당 유저의 `remaining_tries`를 1 차감합니다. (예: 10 -> 9)
11. **(엣지케이스)** DB 저장/업데이트(9, 10) 실패 시: 500 Server Error 응답을 반환합니다. (횟수 차감 없음)
12. (모든 처리 성공) 프론트엔드로 AI 분석 결과(요약, 상세) 및 `analysisId`를 포함하여 200 OK 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) 현재 페이지(`/new-analysis`)에 **요약 내용이 포함된 모달(Modal)**이 표시됩니다. 모달에는 '상세보기' 버튼이 포함됩니다.
* (시스템 측) `analyses` 테이블에 분석 내역 1건이 추가되고, `subscriptions` 테이블의 `remaining_tries`가 1 감소합니다.

---

## ⏳ 6. Pro 사용자의 사주 분석 (횟수 소진)

**1. 입력 (Input)**
* (인증 상태, Pro 플랜) 사용자가 `/new-analysis` 페이지에 접근합니다.
* 폼에 필수 사주 정보를 입력하고 모델을 선택합니다.
* '분석하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 입력값의 유효성을 검증합니다.
2.  (검증 통과) 백엔드 API로 '분석 요청'을 전송합니다. (`userId` 포함)
3.  백엔드 API가 `userId`를 기준으로 Supabase `subscriptions` 테이블을 조회합니다.
4.  (조건 검증) `plan_type` = 'Pro' 이고 `remaining_tries` = 0 인지 확인합니다.
5.  (조건 충족) Gemini API 호출 등 후속 처리를 중단합니다.
6.  프론트엔드로 'Pro 횟수 소진'을 의미하는 특정 에러 코드(예: 403 Forbidden / `QUOTA_EXCEEDED_PRO`)를 반환합니다.

**3. 출력 (Output)**
* (사용자 측) 프론트엔드가 'Pro 횟수 소진' 에러 응답을 수신합니다.
* "이번 달 분석 횟수를 모두 사용했습니다. 다음 결제일에 횟수가 갱신됩니다."와 같은 알림(토스트/모달)을 표시합니다. (리디렉션 없음)
* (시스템 측) 데이터 변경이 없습니다.

---

## 📅 7. Pro 구독 해지 신청 (해지 예약)

**1. 입력 (Input)**
* (인증 상태, Pro 플랜) 사용자가 `/subscription` 페이지에 접근합니다.
* '해지하기' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 '구독 해지 예약' 요청을 백엔드 API (예: `/api/payments/cancel`)로 전송합니다.
2.  백엔드 API가 `userId`를 기준으로 Supabase `subscriptions` 테이블을 조회합니다.
3.  **(엣지케이스)** 조회된 구독 상태가 'Pro'가 아니거나, 이미 '해지 예약' 상태인 경우: 409 Conflict 응답을 반환합니다.
4.  (검증 통과) 토스페이먼츠 API를 호출하거나 빌링키를 삭제하지 **않습니다**.
5.  백엔드는 `subscriptions` 테이블의 해당 유저 레코드에 '해지 예약' 상태를 표시합니다. (예: `cancellation_scheduled` = `true`)
6.  **(엣지케이스)** DB 업데이트(5) 실패 시: 500 Server Error 응답을 반환합니다.
7.  (DB 업데이트 성공) 프론트엔드에 200 OK (해지 예약 성공) 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) `/subscription` 페이지 UI가 갱신됩니다.
    * "다음 결제일([YYYY-MM-DD])까지 구독이 유지됩니다." 안내 메시지 표시.
    * '해지하기' 버튼이 **'해지 취소'** 버튼으로 변경됩니다.
    * 사용자는 결제일 전까지 Pro 혜택을 계속 이용할 수 있습니다.
* (시스템 측) `subscriptions` 테이블에 해지 예약 상태가 기록됩니다.

---

## ↩️ 8. 구독 해지 취소

**1. 입력 (Input)**
* (인증 상태, Pro 플랜, 해지 예약 상태) 사용자가 `/subscription` 페이지에 접근합니다.
* '해지 취소' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  프론트엔드에서 '구독 해지 취소' 요청을 백엔드 API (예: `/api/payments/reactivate`)로 전송합니다.
2.  백엔드 API가 `userId`를 기준으로 `subscriptions` 테이블을 조회합니다.
3.  **(엣지케이스)** 조회된 구독 상태가 '해지 예약' 상태(`cancellation_scheduled` = `true`)가 아닌 경우: 409 Conflict 응답을 반환합니다.
4.  (검증 통과) 백엔드는 `subscriptions` 테이블의 해당 유저 레코드에서 '해지 예약' 상태를 제거합니다. (예: `cancellation_scheduled` = `false`)
5.  **(엣지케이스)** DB 업데이트(4) 실패 시: 500 Server Error 응답을 반환합니다.
6.  (DB 업데이트 성공) 프론트엔드에 200 OK (해지 취소 성공) 응답을 반환합니다.

**3. 출력 (Output)**
* (사용자 측) `/subscription` 페이지 UI가 갱신됩니다.
    * '해지 예약' 관련 안내 메시지가 사라집니다.
    * '해지 취소' 버튼이 다시 **'해지하기'** 버튼으로 변경됩니다.
* (시스템 측) `subscriptions` 테이블의 해지 예약 상태가 `false`로 변경되어 정기결제 대상에 다시 포함됩니다.

---

## ⚙️ 9. 정기 결제 및 구독 갱신 (Cron Job)

**1. 입력 (Input)**
* (시스템) Supabase Cron 스케줄러가 매일 02:00 KST에 `/api/cron/process-subscriptions` 엔드포인트를 트리거합니다.

**2. 처리 (Processing)**
1.  (백엔드 API) API 엔드포인트가 호출됩니다.
2.  **(보안 엣지케이스)** 요청 헤더의 `Authorization` (Cron Secret)을 검증하여 유효하지 않으면 401 Unauthorized를 반환하고 중단합니다.
3.  (DB 조회) `subscriptions` 테이블에서 다음 조건을 **모두** 만족하는 레코드를 조회합니다:
    * `plan_type` = 'Pro'
    * `next_payment_date` = (오늘 날짜)
    * `cancellation_scheduled` = `false` (해지 예약 안 함)
    * `billing_key` IS NOT NULL
4.  **(엣지케이스)** 대상자가 0명일 경우: 200 OK를 반환하고 종료합니다.
5.  (결제 루프) 조회된 구독자 목록을 순회하며 **각 사용자별로** 다음을 실행합니다.
6.  저장된 `billing_key`로 토스페이먼츠 API에 3,900원 정기결제를 요청합니다.
7.  **(결제 성공 시 - 7.S)**
    * `subscriptions` 테이블에서 해당 유저의 레코드를 업데이트합니다.
        * `remaining_tries`: 10 (횟수 갱신)
        * `next_payment_date`: (오늘 날짜 + 1개월)
    * **(크리티컬 엣지케이스 - 7.S.E)** 결제는 성공했으나 DB 업데이트 실패 시: 즉시 오류를 로깅합니다 (관리자 개입 필요).
8.  **(결제 실패 시 - 7.F)** (잔액 부족, 카드 해지 등)
    * `subscriptions` 테이블에서 해당 유저의 레코드를 **즉시 해지** 처리합니다.
        * `plan_type`: 'Free'
        * `remaining_tries`: 0
        * `billing_key`: `null` (빌링키 즉시 삭제)
        * `next_payment_date`: `null`
    * **(엣지케이스 - 7.F.E)** 결제 실패 후 DB 해지 처리 실패 시: 오류를 로깅합니다. (다음 날 결제 재시도 가능성 있음)

**3. 출력 (Output)**
* (사용자 측) 즉각적인 출력은 없습니다. 사용자가 나중에 접속 시 갱신된 상태(연장 또는 해지)를 확인합니다.
* (시스템 측) Supabase `subscriptions` 테이블의 관련 레코드들이 갱신(연장 또는 해지)됩니다.

---

## 🛑 10. 예약된 구독 해지 자동 처리 (Cron Job)

**1. 입력 (Input)**
* (시스템) 유저플로우 9와 동일한 Cron Job (`/api/cron/process-subscriptions`)이 매일 02:00 KST에 트리거됩니다.

**2. 처리 (Processing)**
1.  (백엔드 API) API 엔드포인트가 호출되고 Cron Secret을 검증합니다.
2.  (DB 조회) `subscriptions` 테이블에서 다음 조건을 **모두** 만족하는 레코드를 조회합니다:
    * `plan_type` = 'Pro'
    * `next_payment_date` = (오늘 날짜)
    * `cancellation_scheduled` = `true` (해지를 예약함)
3.  **(엣지케이스)** 대상자가 0명일 경우: 처리를 건너뜁니다.
4.  (해지 루프) 조회된 구독자 목록을 순회하며 **각 사용자별로** 다음을 실행합니다.
5.  **토스페이먼츠 API를 호출하지 않습니다.** (결제 미시도)
6.  Supabase `subscriptions` 테이블에서 해당 유저의 레코드를 'Free' 플랜으로 강등(Downgrade)시킵니다.
    * `plan_type`: 'Free'
    * `remaining_tries`: 0 (혜택 소멸)
    * `billing_key`: `null` (**빌링키 삭제**)
    * `next_payment_date`: `null`
    * `cancellation_scheduled`: `false` (상태 초기화)
7.  **(엣지케이스)** DB 업데이트(6) 실패 시: 오류를 로깅합니다. (다음 날 Cron Job에서 다시 처리 대상이 될 수 있음)

**3. 출력 (Output)**
* (사용자 측) 즉각적인 출력은 없습니다. 사용자가 나중에 접속 시 'Free' 플랜으로 변경된 것을 확인합니다.
* (시스템 측) `subscriptions` 테이블의 해당 레코드가 'Free'로 전환되고 **빌링키가 안전하게 삭제됩니다.**

---

## 📋 11. 분석 내역 조회 (대시보드 / 페이지네이션 적용)

**1. 입력 (Input)**
* (인증 상태) 사용자가 `/dashboard` 페이지로 이동(방문)합니다. (기본 1페이지 요청)
* (선택적) 사용자가 페이지 하단의 페이지 번호(예: '2') 또는 '다음', '이전' 버튼을 클릭합니다.

**2. 처리 (Processing)**
1.  (프론트엔드) 페이지 컴포넌트가 마운트되거나 페이지 번호 입력이 발생합니다.
2.  (프론트엔드) `userId`와 **요청된 페이지 번호**(예: `page=1`, `limit=10`)를 기준으로 백엔드 API에 '분석 내역 목록'을 요청합니다.
3.  (백엔드/DB) `analyses` 테이블에서 `userId`가 일치하는 레코드를 조회합니다.
    * `ORDER BY created_at DESC` (최신순 정렬)
    * `LIMIT 10`
    * `OFFSET (page - 1) * 10`
4.  (백엔드/DB) 별도로 동일한 `userId`의 `analyses` 레코드 **총 개수(Total Count)**를 조회합니다.
5.  **(엣지케이스)** 조회된 분석 내역이 0건일 경우: 빈 배열과 `total_count: 0`을 반환합니다.
6.  **(엣지케이스)** DB 조회 실패 시: 500 Server Error 응답을 반환합니다.
7.  (처리 성공) 조회된 목록(최대 10개)과 페이지네이션 정보(총 개수, 총 페이지 수)를 프론트엔드에 200 OK 응답으로 반환합니다.

**3. 출력 (Output)**
* (사용자 측)
    * (성공, 0건) "아직 분석한 내역이 없습니다." 안내 문구가 표시됩니다.
    * (성공, 1건 이상) 요청한 페이지에 해당하는 사주 내역이 최신순으로 표시됩니다. (각 항목은 상세보기로 링크됨)
    * (성공, 11건 이상) 페이지네이션 UI(예: 1, 2, 3... 버튼)가 하단에 표시됩니다.
    * (실패) "내역을 불러오는 데 실패했습니다." 에러 메시지가 표시됩니다.
* (시스템 측) DB 읽기(Read) 작업만 수행됩니다.

---

## 📑 12. 분석 상세보기 및 MD 파일 다운로드

**1. 입력 (Input)**
* (인증 상태) 사용자가 `/dashboard`에서 특정 분석 내역 항목을 클릭합니다.
* (또는) 사용자가 `/new-analysis`에서 분석 완료 후 모달의 '상세보기' 버튼을 클릭합니다.
* (상세보기 페이지 진입 후) 사용자가 'MD 파일 다운로드' 버튼을 클릭합니다.

**2. 처리 (Processing)**

**A. 상세 내용 조회 (페이지 로드 시)**
1.  (프론트엔드) 페이지 컴포넌트가 마운트되고, URL 경로(예: `/analysis/[analysisId]`)에서 `analysisId`를 추출합니다.
2.  (프론트엔드) `analysisId`와 `userId`를 기준으로 백엔드 API에 상세 데이터를 요청합니다.
3.  (백엔드/DB) `analyses` 테이블에서 `id` = `analysisId` **그리고** `userId` = (현재 사용자 ID)인 레코드를 조회합니다.
4.  **(보안 엣지케이스)** 조회 결과가 없는 경우 (잘못된 ID 또는 타인 ID 접근 시도): 404 Not Found 응답을 반환합니다.
5.  **(엣지케이스)** DB 조회 실패 시: 500 Server Error 응답을 반환합니다.
6.  (처리 성공) 조회된 레코드의 **전체 상세 분석 텍스트** 및 기타 정보를 프론트엔드에 200 OK로 반환합니다.

**B. MD 파일 다운로드 (버튼 클릭 시)**
1.  (프론트엔드) 'MD 파일 다운로드' 버튼이 클릭됩니다.
2.  (프론트엔드) (A)에서 이미 불러온 상세 분석 텍스트(String) 데이터를 가져옵니다.
3.  (프론트엔드) JavaScript를 사용하여 해당 텍스트 문자열을 `Blob` 객체로 변환합니다. (MIME type: `text/markdown`)
4.  다운로드할 파일 이름을 생성합니다. (예: `사주분석결과_[날짜].md`)
5.  생성된 `Blob`을 가리키는 임시 `Object URL`을 생성합니다.
6.  가상의 `<a>` 태그를 동적으로 생성하여 `href`에 `Object URL`을, `download` 속성에 파일 이름을 설정합니다.
7.  가상 `<a>` 태그를 프로그래매틱하게 클릭하여 파일 다운로드 창을 트리거합니다.
8.  `Object URL`을 메모리에서 해제(revoke)합니다.

**3. 출력 (Output)**

**A. 상세 내용 조회**
* (성공) 사용자에게 입력했던 사주 정보와 Gemini가 생성한 **상세 사주 풀이 내용 전체**가 페이지에 표시됩니다.
* (실패 404/500) "분석 내역을 찾을 수 없습니다." 메시지가 표시됩니다.

**B. MD 파일 다운로드**
* (성공) 브라우저가 `.md` 파일 다운로드 대화상자를 띄우거나 즉시 다운로드를 실행합니다.
* (시스템 측) 별도 서버 호출이나 데이터 변경은 없습니다.